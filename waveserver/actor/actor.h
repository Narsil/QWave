#ifndef ACTOR_H
#define ACTOR_H

#include <QObject>
#include <QSharedPointer>
#include "waitingcondition.h"
#include "actor/imessage.h"
#include "actor/actorid.h"

#define TERMINATE() m_state = -1; return;
#define BEGIN_EXECUTE switch(m_state) { case 0:
#define END_EXECUTE ; } m_state = -1;
#define yield(condition) { m_state = __LINE__; m_wait = (condition).donate(); return; case __LINE__: ; }
// #define REASON(t) t* REASON = dynamic_cast<t*>( this->m_reason )
#define REASON(t) t REASON = _REASON<t>( this->m_reason )

template<class R> R _REASON(WaitingConditionImpl* ptr) { return R( ptr ); }

class ActorGroup;
class ActorId;
class QTimerEvent;

/**
  * An actor can be used much like a C# or Python iterator.
  * Its main function EXECUTE() can return in the middle using the 'yield' statement.
  * When the function is invoked again it continues just below the 'yield' statement which caused it to leave.
  * Please note that calling yield does NOT BLOCK the thread. The EXECUTE function is left and the current thread is assigned to other actors.
  *
  * In the yield statement you must return a WaitingCondition, i.e. "yield( Timeout(100) );"
  * When the waiting condition is satisfied, the actor will become ready and continue execution below the yield statement
  * whenever it can get hold of the CPU.
  *
  * Each Actor must be assigned to one ActorGroup, otherwise it will not receive CPU time from the thread.
  *
  * WARNING: Inside EXECUTE do not use local variables since they do not survive multiple invocations.
  * Instead, promote the variables to member fields.
  */
class Actor : public QObject
{
public:
    Actor(ActorGroup* parent);
    Actor(const QString& id, ActorGroup* parent);
    virtual ~Actor();

    /**
      * @internal
      *
      * Invoked by ActorGroup. Use ActorGroup::addActor instead.
      */
    ActorGroup* group() const;

    /**
      * This function takes ownership of the message being passed. Do not modify the message after it has been passed to send.
      *
      * @return true if the message could be sent. If the message travels over the network it could still be lost, i.e.
      *         the function does not wait for an ACK.
      */
    virtual bool send( IMessage* msg );
    /**
      * This function takes ownership of the message being passed. Do not modify the message after it has been passed to send.
      *
      * @return true if the message could be sent. If the message travels over the network it could still be lost, i.e.
      *         the function does not wait for an ACK.
      */
    virtual bool post( IMessage* msg );

    void setActorId( const QString& id ) { m_id = ActorId( group(), id ); setObjectName(id); }
    const ActorId& actorId() const { return m_id; }

protected:
    /**
      * The generated ID is unique among all IDs generated by the same actor group and can be used to give messages a unique ID.
      */
    qint64 nextId();

    /**
      * This function is the main loop of the actor.
      */
    virtual void execute() = 0;

    virtual void customEvent( QEvent* event );
    virtual void timerEvent( QTimerEvent* event );

    /**
      * @internal
      *
      * The waiting condition which has completed or 0.
      */
    WaitingConditionImpl* m_reason;
    /**
      * @internal
      */
    WaitingConditionImpl* m_wait;
    /**
      * @internal
      */
    int m_state;

private:
    bool run();
    void deleteWait();
    void deleteReason();

    ActorId m_id;

    static qint64 s_id;
};

#endif // ACTOR_H
